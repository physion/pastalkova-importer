function epoch = importEpoch(group, protocol, params, data, epochDescriptor, inputSources, analysisProtocol)
    import ovation.*;
    
    protocolParams = params.epochGroup.protocol;
    protocolParams.wheelDirectionChoice = data.Laps.whlDirChoice(epochDescriptor.trialNumber);
    
    devParameters = data.xml;
    egroups = struct();
    for i = 1:length(data.xml.ElecGp)
        g = data.xml.ElecGp{i};
        egroups(i).group = g;
    end
    devParameters.ElecGp = egroups;
    deviceParameters = struct2map(devParameters);
    deviceParameters.putAll(struct2map(params.device.tracking));
    
    epoch = group.insertEpoch(inputSources,...
        [],... % No output sources
        group.getStart().plusSeconds(epochDescriptor.startTimeSeconds),...
        group.getStart().plusSeconds(epochDescriptor.endTimeSeconds),...
        protocol,...
        struct2map(protocolParams),...
        deviceParameters);
    
    
    disp('    Importing responses...');
    importResponses(epoch, group, params, data, epochDescriptor);
    
    disp('    Importing analysis records...');
    epoch.getDataContext().beginTransaction()
    importAnalysisRecords(epoch, params, data, epochDescriptor, analysisProtocol);
    epoch.getDataContext().commitTransaction();
    
    disp('    Importing annotations...');
    importAnnotations(epoch, params, data, epochDescriptor);
    
    disp('    Waiting for uploads to complete...');
    waitForPendingUploads(group.getDataContext());
    
end

function epoch = importAnnotations(epoch, params, data, epochDescriptor) %#ok<INUSL>
    
    cwStarts = data.Laps.WhlLfpIndStartCW{epochDescriptor.trialNumber} - data.Laps.startLfpInd(epochDescriptor.trialNumber);
    cwStops = data.Laps.WhlLfpIndEndCW{epochDescriptor.trialNumber} - data.Laps.startLfpInd(epochDescriptor.trialNumber);
    
    importWheelRuns(epoch, 'cw', 'Wheel Run CW', cwStarts, cwStops, data);
    
    ccwStarts = data.Laps.WhlLfpIndStartCCW{epochDescriptor.trialNumber} - data.Laps.startLfpInd(epochDescriptor.trialNumber);
    ccwStops = data.Laps.WhlLfpIndEndCCW{epochDescriptor.trialNumber} - data.Laps.startLfpInd(epochDescriptor.trialNumber);
    
    importWheelRuns(epoch, 'ccw', 'Wheel Run CCW', ccwStarts, ccwStops, data);
end

function epoch = importWheelRuns(epoch, tagSuffix, text, starts, stops, data)
    
    if(all(size(starts) == size(stops)))
        
        for i = 1:numel(starts)
            
            startTime = epoch.getStart().plusMillis(1000 * starts(i) / data.xml.lfpSampleRate);
            endTime = epoch.getStart().plusMillis(1000 * stops(i) / data.xml.lfpSampleRate);
            
            if(i == numel(starts))
                prefix = ['last-wheel-run-' tagSuffix];
            else
                prefix = ['wheel-runs-' tagSuffix];
            end
            
            annotation = epoch.addTimelineAnnotation(text,...
                [prefix '  lfpStartIndex: ' num2str(starts(i)) ' lfpEndIndex: ' num2str(stops(i))],...
                startTime,...
                endTime);
            
        end
    else
        warning('pastalkova:ovation:import',...
            'Wheel run starts and stops do not match. Skipping Wheel Run Annotations');
    end
end

function epoch = importAnalysisRecords(epoch, ~, data, epochDescriptor, analysisProtocol)
    import ovation.*;
    import us.physion.ovation.values.NumericData;
    
    analysisParameters = struct2map(struct()); %TODO parameters?
    
    % EEG
    nd = NumericData().addData('LFP',...
        data.Track.eeg(epochDescriptor.lfpStartIndex:epochDescriptor.lfpEndIndex),...
        'unknown',... % TODO units
        data.xml.lfpSampleRate,...
        'Hz');
    
    inputs = java.util.HashMap();
    inputs.put('eegRaw', epoch.getMeasurement('LFP'));
        
    eegAnalysis = epoch.addAnalysisRecord('EEG',...
        inputs,...
        analysisProtocol,...
        analysisParameters);
    
    eegAnalysis.addNumericOutput('Downsampled EEG', nd);
    
    
    % Behavior type
    derivedResponses.Laps.behavType = derivedResponseDescriptor('n/a', 1, 'trial^{-1}', epochDescriptor.trialNumber, 'assesment');
    
    
    % Tracking derived responses
    nlapcw = unique(data.Laps.NLapCW(epochDescriptor.lfpStartIndex:epochDescriptor.lfpEndIndex));
    if(~all(nlapcw == epochDescriptor.trialNumber | nlapcw == 0))
        warning('pastalkova:ovation:import',...
            'NLapCW does not agree with Epoch trial number.');
    end
    
    nlapccw = unique(data.Laps.NLapCCW(epochDescriptor.lfpStartIndex:epochDescriptor.lfpEndIndex));
    if(~all(nlapccw == epochDescriptor.trialNumber | nlapccw == 0))
        warning('pastalkova:ovation:import',...
            'NLapCCW does not agree with Epoch trial number.');
    end
    
    distanceUnits = '?'; % TODO units
    speedUnits = '?'; % TODO units
    derivedResponses.Laps.WhlDistCW = derivedResponseDescriptor(distanceUnits,...
        data.xml.lfpSampleRate, 'Hz', epochDescriptor.lfpStartIndex:epochDescriptor.lfpEndIndex, 'distance');
    derivedResponses.Laps.WhlLapsDistCW = derivedResponseDescriptor(distanceUnits,...
        data.xml.lfpSampleRate, 'Hz', epochDescriptor.lfpStartIndex:epochDescriptor.lfpEndIndex, 'distance');
    derivedResponses.Laps.WhlSpeedCW = derivedResponseDescriptor(speedUnits,...
        data.xml.lfpSampleRate, 'Hz', epochDescriptor.lfpStartIndex:epochDescriptor.lfpEndIndex, 'spped');
    
    
    derivedResponses.Laps.WhlDistCCW = derivedResponseDescriptor(distanceUnits,...
        data.xml.lfpSampleRate, 'Hz', epochDescriptor.lfpStartIndex:epochDescriptor.lfpEndIndex, 'distance');
    derivedResponses.Laps.WhlLapsDistCCW = derivedResponseDescriptor(distanceUnits,...
        data.xml.lfpSampleRate, 'Hz', epochDescriptor.lfpStartIndex:epochDescriptor.lfpEndIndex, 'distance');
    derivedResponses.Laps.WhlSpeedCCW = derivedResponseDescriptor(speedUnits,...
        data.xml.lfpSampleRate, 'Hz', epochDescriptor.lfpStartIndex:epochDescriptor.lfpEndIndex, 'speed');
    
    mmUnits = 'mm'; %TODO check
    derivedResponses.Track.xMM = derivedResponseDescriptor(mmUnits,...
        data.xml.lfpSampleRate,...
        'Hz',...
        epochDescriptor.lfpStartIndex:epochDescriptor.lfpEndIndex,....
        'distance');
    
    derivedResponses.Track.yMM = derivedResponseDescriptor(mmUnits,...
        data.xml.lfpSampleRate,...
        'Hz',...
        epochDescriptor.lfpStartIndex:epochDescriptor.lfpEndIndex,....
        'distance');
    
    derivedResponses.Track.mazeSect = derivedResponseDescriptor('n/a',...
        data.xml.lfpSampleRate,...
        'Hz',...
        epochDescriptor.lfpStartIndex:epochDescriptor.lfpEndIndex,....
        'section');
    
    derivedResponses.Track.speed_MMsec = derivedResponseDescriptor('mm/s',...
        data.xml.lfpSampleRate,...
        'Hz',...
        epochDescriptor.lfpStartIndex:epochDescriptor.lfpEndIndex,....
        'speed');
    
    derivedResponses.Track.accel_MMsecSq = derivedResponseDescriptor('mm/s^2',...
        data.xml.lfpSampleRate,...
        'Hz',...
        epochDescriptor.lfpStartIndex:epochDescriptor.lfpEndIndex,....
        'acceleration');
    
    derivedResponses.Track.headDirDeg = derivedResponseDescriptor('degrees',...
        data.xml.lfpSampleRate,...
        'Hz',...
        epochDescriptor.lfpStartIndex:epochDescriptor.lfpEndIndex,....
        'direction');
    
    derivedResponses.Track.realDistMM = derivedResponseDescriptor(mmUnits,...
        data.xml.lfpSampleRate,...
        'Hz',...
        epochDescriptor.lfpStartIndex:epochDescriptor.lfpEndIndex,....
        'distance');
    
    derivedResponses.Track.linXMM = derivedResponseDescriptor(mmUnits,...
        data.xml.lfpSampleRate,...
        'Hz',...
        epochDescriptor.lfpStartIndex:epochDescriptor.lfpEndIndex,....
        'distance');
    
    derivedResponses.Track.linYMM = derivedResponseDescriptor(mmUnits,...
        data.xml.lfpSampleRate,...
        'Hz',...
        epochDescriptor.lfpStartIndex:epochDescriptor.lfpEndIndex,....
        'distance');
    
    derivedResponses.Track.linXPix = derivedResponseDescriptor('pixels',...
        data.xml.lfpSampleRate,...
        'Hz',...
        epochDescriptor.lfpStartIndex:epochDescriptor.lfpEndIndex,....
        'distance');
    
    derivedResponses.Track.linYPix = derivedResponseDescriptor('pixels',...
        data.xml.lfpSampleRate,...
        'Hz',...
        epochDescriptor.lfpStartIndex:epochDescriptor.lfpEndIndex,....
        'distance');
    
    derivedResponses.Track.linDistMM = derivedResponseDescriptor(mmUnits,...
        data.xml.lfpSampleRate,...
        'Hz',...
        epochDescriptor.lfpStartIndex:epochDescriptor.lfpEndIndex,....
        'distance');
    
    thetaUnits = '?'; %TODO Units
    derivedResponses.Track.thetaPhHilb = derivedResponseDescriptor(thetaUnits,...
        data.xml.lfpSampleRate,...
        'Hz',...
        epochDescriptor.lfpStartIndex:epochDescriptor.lfpEndIndex,....
        'phase'); %TODO label
    
    derivedResponses.Track.thetaPhLinInterp = derivedResponseDescriptor(thetaUnits,...
        data.xml.lfpSampleRate,...
        'Hz',...
        epochDescriptor.lfpStartIndex:epochDescriptor.lfpEndIndex,....
        'phase'); %TODO label
    
    
    derivedResponseGroupNames = fieldnames(derivedResponses);
    for i = 1:length(derivedResponseGroupNames)
        drGroupName = derivedResponseGroupNames{i};
        drGroup = derivedResponses.(drGroupName);
        
        record = epoch.addAnalysisRecord(drGroupName,...
            namedMap(epoch.getMeasurements()),... %TODO which measurements?
            analysisProtocol,...
            analysisParameters);
        
        derivedResponseNames = fieldnames(drGroup);
        for j = 1:length(derivedResponseNames)
            drName = derivedResponseNames{j};
            drDescriptor = drGroup.(drName);
            
            samples = data.(drGroupName).(drName)';
            if(~isempty(drDescriptor.ind))
                samples = samples(drDescriptor.ind);
            end
            
            
            nd = NumericData().addData(drName,...
                samples,...
                drDescriptor.units,...
                drDescriptor.samplingRate,...
                drDescriptor.samplingUnits);
            
            record.addNumericOutput(drName, nd);
        end
    end
    
    
    
    
    % Theta
    startSeconds = (epoch.getStart().getMillis() - epoch.getParent().getStart().getMillis) / 1000;
    endSeconds = (epoch.getEnd().getMillis() - epoch.getParent().getEnd().getMillis) / 1000;
    
    derivationParameters = struct(); % TODO parameters
    
    thetaAnalysis = epoch.addAnalysisRecord('Theta',...
            namedMap(epoch.getMeasurements()),... %TODO which measurements?
            analysisProtocol,...
            analysisParameters);
        
    insertThetaEvents(epoch,...
        derivationParameters,...
        data.Track.thetaPeak_tAmpl,...
        startSeconds,...
        endSeconds,...
        'Theta peak',...
        'thetaPeak',...
        thetaAnalysis);
    
    insertThetaEvents(epoch,...
        derivationParameters,...
        data.Track.thetaTrough_tAmpl,...
        startSeconds,...
        endSeconds,...
        'Theta trough',...
        'thetaTrough',...
        thetaAnalysis);
    
    insertThetaEvents(epoch,...
        derivationParameters,...
        data.Track.thetaPtoTZeros_tAmpl,...
        startSeconds,...
        endSeconds,...
        'Theta peak-to-trough 0-crossing',...
        'thetaPtoTZero',...
        thetaAnalysis);
    
    insertThetaEvents(epoch,...
        derivationParameters,...
        data.Track.thetaTtoPZeros_tAmpl,...
        startSeconds,...
        endSeconds,...
        'Theta trough-to-peak 0-crossing',...
        'thetaTtoPZeros',...
        thetaAnalysis);
    
    % SPW events
    spwAnalysis = epoch.addAnalysisRecord('SPW',...
        namedMap(epoch.getMeasurements()),... %TODO which measurements?
        analysisProtocol,...
        analysisParameters);
    
    if(isfield(data.Track, 'spw_peakT'))
        insertSpwTimeEvents(epoch,...
            data,...
            epochDescriptor,...
            derivationParameters,...
            data.Track.spw_peakT,...
            'spw peak time',...
            'spw_peak',...
            spwAnalysis);
    end
    
    if(isfield(data.Track, 'spw_startT'))
        insertSpwTimeEvents(epoch,...
            data,...
            epochDescriptor,...
            derivationParameters,...
            data.Track.spw_startT,...
            'spw peak start',...
            'spw_start',...
            spwAnalysis);
    end
    
    if(isfield(data.Track, 'spw_endT'))
        insertSpwTimeEvents(epoch,...
            data,...
            epochDescriptor,...
            derivationParameters,...
            data.Track.spw_endT,...
            'spw peak end',...
            'spw_end',...
            spwAnalysis);
    end
    
    
    if(isfield(data.Track, 'spw_shpwPeakAmplSD'))
        values = data.Track.spw_shpwPeakAmplSD(epochDescriptor.lfpStartIndex <= data.Track.spw_peakT & ...
            data.Track.spw_peakT <= epochDescriptor.lfpEndIndex);
        if(~isempty(values))
            nd = NumericData().addData('shpwPeakAmplSD',...
                values,...
                '?',... %TODO units
                1,... %TODO sampling Rate?
                'Hz');
            
            spwAnalysis.addNumericOutput('shpw Peak Amplitude SD', nd);
        end
    end
    
    if(isfield(data.Track, 'spw_ripPeakAmplSD'))
        values = data.Track.spw_ripPeakAmplSD(epochDescriptor.lfpStartIndex <= data.Track.spw_peakT & ...
            data.Track.spw_peakT <= epochDescriptor.lfpEndIndex);
        if(~isempty(values))
            nd = NumericData().addData('ripPeakAmplSD',...
                values,...
                '?',... %TODO units
                1,... %TODO sampling Rate?
                'Hz');
            
            spwAnalysis.addNumericOutput('rip Peak Amplitude SD', nd);
        end
    end
        
    
    % Spikes
    spikeIdx = find(epochDescriptor.lfpStartIndex <= data.Spike.res & ...
        data.Spike.res <= epochDescriptor.lfpEndIndex);
    
    derivationParameters = struct();
    for i = 1:length(data.xml.SpkGrps)
        derivationParameters.(['spike_group_' num2str(i)]) = data.xml.SpkGrps(i);
        if(isfield(derivationParameters.(['spike_group_' num2str(i)]), 'clu'))
            error('pastalkova:ovation:import',...
                'Spike derivation parameters alread has a .clu field');
        end
        derivationParameters.(['spike_group_' num2str(i)]).clu = data.Clu;
    end
    
    spikeAnalysis = epoch.addAnalysisRecord('Spikes',...
        namedMap(epoch.getMeasurements()),... %TODO which measurements?
        analysisProtocol,...
        analysisParameters);
    
	% TODO please confirm that .res and .res20kHz are the lfp and raw sample indexes of each spike
    spikeLfpIndex = data.Spike.res(spikeIdx) - epochDescriptor.lfpStartIndex;
    
    spikeAnalysis.addNumericOutput('spike-index-lfp', NumericData().addData('index',...
        spikeLfpIndex,...
        'n/a',...
        1,...
        '1/spike'));
    
    
    spikeTimeSeconds = spikeLfpIndex / data.xml.lfpSampleRate;
    spikeAnalysis.addNumericOutput('spike time seconds', NumericData().addData('time',...
        spikeTimeSeconds,...
        's',...
        1,...
        '1/spike'));
    
    rawStartIndex = floor(epochDescriptor.lfpStartIndex * data.xml.SampleRate / data.xml.lfpSampleRate);
    spikeRawIndex = data.Spike.res20kHz(spikeIdx) - rawStartIndex;
    spikeAnalysis.addNumericOutput('spike index 20kHz', NumericData().addData('index',...
        spikeRawIndex,...
        'index',...
        1,...
        '1/spike'));
    
    spikeTimeSeconds = spikeRawIndex / data.xml.SampleRate;
    spikeAnalysis.addNumericOutput('spike time seconds (raw)', NumericData().addData('time',...
        spikeTimeSeconds,...
        'index',...
        1,...
        '1/spike'));
    
    spikeAnalysis.addNumericOutput('spike cluster', NumericData().addData('cluster',...
        data.Spike.clu(spikeIdx),...
        'index',...
        1,...
        '1/spike'));
    
    spikeAnalysis.addNumericOutput('spike shank', NumericData().addData('shank',...
        data.Spike.shank(spikeIdx),...
        'index',...
        1,...
        '1/spike'));
    
    
    spikeAnalysis.addNumericOutput('spike totClu', NumericData().addData('index',...
        data.Spike.totclu(spikeIdx),...
        'index',...
        1,...
        '1/spike'));
    
    
    
    spikeAnalysis.addNumericOutput('spike burst index', NumericData().addData('index',...
        data.Spike.IDBurst(spikeIdx),...
        'index',...
        1,...
        '1/spike'));
    
    
    spikeAnalysis.addNumericOutput('spike burst length', NumericData().addData('length',...
        data.Spike.burstLength(spikeIdx),...
        'index',...
        1,...
        '1/spike'));
    
    spikeAnalysis.addNumericOutput('spike order in burst', NumericData().addData('order',...
        data.Spike.orderInBurst(spikeIdx),...
        'index',...
        1,...
        '1/spike'));
    
    
    spikeIdx = spikeIdx(spikeIdx <= length(data.Spike.thPhaseHilb));
    spikeAnalysis.addNumericOutput('spike theta phase (Hilbert)', NumericData().addData('phase',...
        data.Spike.thPhaseHilb(spikeIdx),...
        '?',... %TODO units
        1,...
        '1/spike'));
    
    spikeAnalysis.addNumericOutput('spike theta phase (Interp)', NumericData().addData('phase',...
        data.Spike.burstLength(spikeIdx),...
        '?',... %TODO units
        1,...
        '1/spike'));
end

function insertThetaEvents(epoch, ~,... %parameters
        events, startSeconds, endSeconds, text, annotationGroup, analysisRecord)
    
    import ovation.*;
    import us.physion.ovation.values.NumericData;
    
    eventRows = events(startSeconds <= events(:,1) & events(:,1) <= endSeconds, :);
    if(~isempty(eventRows))
        for r = eventRows
            eventTime = epoch.getParent().getStart().plusMillis(r(1) * 1000);
            epoch.addTimelineAnnotation(text, annotationGroup, eventTime);
        end
        
        
        nd = NumericData().addData([annotationGroup ' Time'],...
            eventRows(:,1),...
            's',...
            1,...
            '1/event');
        analysisRecord.addNumericOutput([annotationGroup ' Time'], nd);
        
        nd = NumericData().addData([annotationGroup 'Amplitude'],...
            eventRows(:, 2),...
            'unknown',... %TODO units
            1,...
            '1/event');
        analysisRecord.addNumericOutput([annotationGroup 'Amplitude'], nd);
    end
end

function insertSpwTimeEvents(epoch, data, epochDescriptor, ~, events, text, annotationGroup, analysisRecord)
    import ovation.*;
    import us.physion.ovation.values.NumericData;
    
    epochEvents = events(epochDescriptor.lfpStartIndex <= events & events <= epochDescriptor.lfpEndIndex) - epochDescriptor.lfpStartIndex;
    eventMillis = zeros(1, length(epochEvents));
    for i = 1:length(epochEvents)
        eventMillis(i) = events(i) / data.xml.lfpSampleRate;
        eventTime = epoch.getStart().plusMillis(eventMillis(i));
        epoch.addTimelineAnnotation(text, annotationGroup, eventTime);
        
    end
    
    if(~isempty(eventMillis))
        nd = NumericData().addData(annotationGroup,...
            eventMillis,...
            'ms',...
            1,...
            '1/event');
        analysisRecord.addNumericOutput(annotationGroup, nd);
    end
    
end

function d = derivedResponseDescriptor(units, srate, srateUnits, ind, dimLabel)
    d.units = units;
    d.samplingRate = srate;
    d.samplingUnits = srateUnits;
    d.ind = ind;
    d.dimLabel = dimLabel;
end

function epoch = importResponses(epoch,...
        ~,... % group
        ~,... % params 
        data,...
        epochDescriptor)
    
    
    import ovation.*;
    import us.physion.ovation.values.NumericData;
    
    % LFP Response
    startIndex = floor(epochDescriptor.lfpStartIndex * data.xml.SampleRate / data.xml.lfpSampleRate);
    endIndex = floor(epochDescriptor.lfpEndIndex * data.xml.SampleRate / data.xml.lfpSampleRate);
    
    nd = NumericData().addData('LFP',...
        single(data.Track.eegRaw(startIndex:endIndex)),... %TODO 32-bit float?
        'unknown',... %TODO units?
        data.xml.SampleRate,...
        'Hz');
    
    epoch.insertNumericMeasurement('LFP',...
        epoch.getInputSources().keySet(),... %TODO all sources?
        array2set({'channel'}),... %TODO which device does this come from?
        nd);
    
        
    % Arduino Responses
    nd = NumericData().addData('choice',...
        data.Laps.dirChoice(epochDescriptor.trialNumber),...
        'n/a',...
        1,...
        '1/trial');
    epoch.insertNumericMeasurement('Direction Choice',...
        array2set({'mouse'}),...
        array2set({'arduino'}),...
        nd);
    
    if(data.Laps.corrChoice(epochDescriptor.trialNumber))
        epoch.addTag('correct');
    end
    
    % Tracking Response
    nd = NumericData().addData('x-position',...
        data.Track.xPix(epochDescriptor.lfpStartIndex:epochDescriptor.lfpEndIndex),...
        'pixels',...
        data.xml.lfpSampleRate,...
        'Hz').addData('y-position',...
        data.Track.yPix(epochDescriptor.lfpStartIndex:epochDescriptor.lfpEndIndex),...
        'pixels',...
        data.xml.lfpSampleRate,...
        'Hz');
    epoch.insertNumericMeasurement('Tracking',...
        array2set({'mouse'}),...
        array2set({'tracking'}),...
        nd);
end